---
title: "Robin's GM analysis"
format: html
execute:
  echo: false
---

```{r setup}
#| include: FALSE
#| echo: FALSE
require(geomorph)
require(scales)
require(ggplot2)
library(tidyverse)
```

# 1. Importing landmarks into R

```{r}
#| warning: FALSE
landmarks <- geomorph::readland.tps(file="robin_conodonts.TPS",
                          readcurves = TRUE,
                          specID = "imageID")
```

# 2. Procrustes analysis

```{r}
landmarks.gpa<-geomorph::gpagen(landmarks)
plot(landmarks.gpa)
```

## Adding links between landmarks (optional)

Robin: if you want to connect the landmarks to create a shape, you will have to click pairs of landmarks (only once per analysis). This is triggered by the following command. Only run it if you are ready to click through all the pairs of landmarks ;-)

```{r}
#| eval: FALSE
# landmarks.gpa$links <- geomorph::define.links(landmarks.gpa$coords[,,1])
```

If you define the links, save your dataset directly into an R object, otherwise you have to re-run it:

```{r}
# saveRDS(landmarks.gpa, file="landmarks.gpa.RData")
# landmarks.gpa <- readRDS(file="landmarks.gpa.RData")
```

## Plotting the landmarks prior to the Procrustes analysis

See the dispersion between the specimens:

```{r}
#| fig-cap: "Dispersion of landmarks across specimens"
# geomorph::plotAllSpecimens(landmarks.gpa$coords,
#                  links = landmarks.gpa$links)
```

the `links = landmarks.gpa$links` line only works if you have defined the links

# 3. Principal Component Analysis

## PC1 and PC2

```{r}
PCA <- geomorph::gm.prcomp(landmarks.gpa$coords) 
plot(PCA, main = expression("PC1 and PC2 of "*italic(T.~gracilis)*" shapes"))
```

```{r}
#| label: PC1 and PC2 with labels
# plot(PCA$x[,1], PCA$x[,2],
#      pch = 16,
#      xlab = "PC 1",
#      ylab = "PC 2",
#      main = expression("PC1 and PC2 of "*italic(T.~gracilis)*" shapes")
# )
# text(x = PCA$x[,1],
#      y = PCA$x[,2],
#      labels = dimnames(landmarks.gpa$coords)[[3]],
#      pos = 1,
#      cex = 0.7
#      )
```

## PC3 and PC4

```{r}
plot(PCA,
     axis1 = 3,
     axis2 = 4,
     main = expression("PC3 and PC4 of "*italic(T.~gracilis)*" shapes"),
     xlim = c(-0.10,0.10),
     ylim = c(-0.05, 0.05)
     )
```

# 4. Assigning relative ages to the samples

Import pixel coordinates (scaled to meters) from WebPlotDigitizer

```{r}
bedCoords <- read.csv(file = "BedCoordinates.csv")
kyrCoords <- read.csv(file = "KyrCoordinates.csv")
```

Set all positions relative to Hangenberg Lower Boundary (HLB)

```{r}
bedHLB <- bedCoords[1,2]
kyrHLB <- kyrCoords[14,2]

bedCoords$FromHLB  <- (bedCoords$y - bedHLB) * -1
kyrCoords$FromHLBx <- (kyrCoords$x - kyrHLB) * -1
```

Scale kyrCoords so that distance from KUB to HLB is same as in `bedCoords`.
`bedCoords[27,3] / kyrCoords[2,3]` is a scale factor used to transform the distance from HLB.

```{r}
kyrCoords$FromHLB <- kyrCoords$FromHLBx * (bedCoords[27,3] / kyrCoords[2,3])
```

Combine both tables, reorder rows in ascending distance from HLB, and remove duplicate KUB and HLB rows
`sp` = stratigraphic positions

```{r}
sp <- data.frame(points = c(bedCoords$point, kyrCoords$point), distance = c(bedCoords$FromHLB, kyrCoords$FromHLB))
sp <- sp %>% arrange(distance)
sp <- sp %>% distinct(points, distance, .keep_all = TRUE)
```

Calculate relative ages

```{r}
sp$distance <- sp$distance - sp[1,2]
sp$age = NA

kyrs_per_trans <- 100
t              <- 0   # just a counter for the for-loop below

for (i in 1:nrow(sp)) {
  # adds 100 to each successive trans row
  if (grepl("trans", sp$points[i])){   
    sp[i,3] = 0 + t
    t <- t + kyrs_per_trans
  }
  # calculates the relative age of each bed
  else{
    trans_index <- which(sp$points == "trans")
    next_trans  <- min(trans_index[trans_index > i])
    prev_trans  <- max(trans_index[trans_index < i])
    sp[i,3] = kyrs_per_trans * sp[i,2] / (sp[next_trans,2] - sp[prev_trans,2])
  }
}
```

```{r}
# make final relative ages table

sp2     <- sp[!sp$points=="trans",]
sp2$age <- sp2$age - sp[2,3]
age     <- data.frame(bed = sp2$points, age = sp2$age)

# and a table for just 100-kyr transitions (considered adding this to the plots but idk)

sp3         <- sp[sp$points=="trans",]
sp3$age     <- sp3$age - sp[2,3]
transitions <- data.frame(transition = sp3$points, age = sp3$age)
```

```{r}
#| label: Extract bed name from file names
sample_names <- gsub("\\D*","",dimnames(landmarks.gpa$coords)[[3]])
sample_names <- as.numeric(sample_names)
sample_names <- data.frame(sample_names)
```

```{r}
#| label: Match sample names with ages in section
positions <- merge(x = sample_names,
      y = age,
      by.x = "sample_names",
      by.y = "Bed",
      all.x = T)
```

## original relative ages

```{r}
#| label: Import relative age data
#age_OLD <- read.csv(file = "RelativeAges.csv",
#                 sep = ",",
#                 header = T)
```

# 5. Change in PCs over time

## 5.1 Mean change of shape across beds

Create a list (`PC`) which contains two matrices: one for the means (`[[1]]`) and one for the standard deviations (`[[2]]`) per bed. Each row corresponds to one PC, so e.g. the value for the mean of PC3 in bed 213 can be accessed as follows: `PC[[1]][3,1]`

```{r}
#| label: means and SDs per bed of each PC
Ages_PC <- cbind(PCA$x, positions)
Ages_PC$Age <- as.factor(Ages_PC$Age)

PC <- list("Mean" = matrix(nrow = dim(PCA$x)[2], 
                           ncol = length(levels(Ages_PC$Age))),
           "SD" = matrix(nrow = dim(PCA$x)[2],
                          ncol = length(levels(Ages_PC$Age))))

for (i in 1:dim(PCA$x)[2]) {
  PC[[1]][i,] <- tapply(Ages_PC[,i], Ages_PC$Age, mean)
  PC[[2]][i,] <- tapply(Ages_PC[,i], Ages_PC$Age, sd)
}
```

## 5.2 Linear Regression Analyses

```{r}
lm_pc1 <- lm(positions$Age/1000 ~ PCA$x[,1])

summary(lm_pc1)
```

```{r}
lm_pc2 <- lm(positions$Age/1000 ~ PCA$x[,2])

summary(lm_pc2)
```

```{r}
lm_pc3 <- lm(positions$Age/1000 ~ PCA$x[,3])

summary(lm_pc3)
```

## 5.3 Change in PC1 over time

```{r}
#| label: plot means and SDs of PC1

plot(
  x = as.numeric(levels(Ages_PC$Age))/1000,
  y = PC[[1]][1,],
  main = "Change in PC1 over time",
  type = "l",
  xlab="Relative Age (Myr)",
  ylab="PC1",
  yaxt = "n",
  ylim = c(-0.08,0.08)
)

#colors in the eccentricity cycles, but that might be kind of redundant
#for (i in 1:(nrow(transitions))){
#  if (i %% 2 != 0){
#    rect(transitions[i,2], -1, transitions[i+1,2], 1,col=rgb(0,0,1,.133),border=NA)
#  }
#}

abline(v=0, lty=2)

text(-0.008, 0, labels = "Hangenberg Black Shale", srt="-270", cex=0.8)

points(
  x = positions$Age/1000,
  y = PCA$x[,1],
  col = "red",
)

arrows(
  x0 = as.numeric(levels(Ages_PC$Age))/1000,
  x1 = as.numeric(levels(Ages_PC$Age))/1000,
  y0 = PC[[1]][1,] - PC[[2]][1,],
  y1 = PC[[1]][1,] + PC[[2]][1,],
  code = 3,
  angle = 90,
  length = 0.05,
)
```

## 5.4 Change in PC2 over time

```{r}
#| label: plot means and SDs of PC2

plot(
  x = as.numeric(levels(Ages_PC$Age))/1000,
  y = PC[[1]][2,],
  main = "Change in PC2 over time",
  type = "l",
  xlab="Relative Age (Myr)",
  ylab="PC2",
  yaxt = "n",
  ylim = c(-0.08,0.08)
)

abline(v=0, lty=2)

text(-0.008, 0, labels = "Hangenberg Black Shale", srt="-270", cex=0.8)

points(x = positions$Age/1000,
       y = PCA$x[,2],
       col = "red",
)

arrows(x0 = as.numeric(levels(Ages_PC$Age))/1000,
       x1 = as.numeric(levels(Ages_PC$Age))/1000,
       y0 = PC[[1]][2,] - PC[[2]][2,],
       y1 = PC[[1]][2,] + PC[[2]][2,],
       code = 3,
       angle = 90,
       length = 0.05,
)

```

## 5.5 Change in PC3 over time

```{r}
#| label: plot means and SDs of PC3

plot(
  x = as.numeric(levels(Ages_PC$Age))/1000,
  y = PC[[1]][3,],
  main = "Change in PC3 over time",
  type = "l",
  xlab="Relative Age (Myr)",
  ylab="PC3",
  yaxt = "n",
  ylim = c(-0.08,0.08)
)

abline(v=0, lty=2)

text(-0.008, 0, labels = "Hangenberg Black Shale", srt="-270", cex=0.8)

points(
  x = positions$Age/1000,
  y = PCA$x[,3],
  col = "red",
)

arrows(
  x0 = as.numeric(levels(Ages_PC$Age))/1000,
  x1 = as.numeric(levels(Ages_PC$Age))/1000,
  y0 = PC[[1]][3,] - PC[[2]][3,],
  y1 = PC[[1]][3,] + PC[[2]][3,],
  code = 3,
  angle = 90,
  length = 0.05,
)
```

# 6. Exploring shape variation across PC space

## Mean shape of *Tripodellus gracilis*

```{r}
meanshape <- mshape(landmarks.gpa$coords)
plot(meanshape)
```

## Exploring PC1

```{r}
#| label: PC1 Min vs Mean Shape
plotRefToTarget(
  meanshape,
  PCA$shapes$shapes.comp1$min,
  method = "vector",
  mag = 2
)
```

```{r}
#| label: PC1 Max vs Mean Shape
plotRefToTarget(
  meanshape,
  PCA$shapes$shapes.comp1$max,
  method = "vector",
  mag = 2
)
```

```{r}
#| label: PC1 Min vs Max
plotRefToTarget(PCA$shapes$shapes.comp1$min, PCA$shapes$shapes.comp1$max,
                method = "vector",
                mag = 1)
```

## Exploring PC2

```{r}
#| label: PC2 Min vs Mean Shape
plotRefToTarget(
  meanshape,
  PCA$shapes$shapes.comp2$min,
  method = "vector",
  mag = 2
)
```

```{r}
#| label: PC2 Max vs Mean Shape
plotRefToTarget(
  meanshape,
  PCA$shapes$shapes.comp2$max, 
  method = "vector",
  mag = 2)
```

```{r}
#| label: PC2 Min vs Max
plotRefToTarget(
  PCA$shapes$shapes.comp2$min,
  PCA$shapes$shapes.comp2$max,
  method = "vector",
  mag = 1
)
```

## Exploring PC3

```{r}
#| label: PC3 Min vs Mean Shape
plotRefToTarget(
  meanshape, 
  PCA$shapes$shapes.comp3$min,
  method = "vector",
  mag = 2
)
```

```{r}
#| label: PC3 Max vs Mean Shape
plotRefToTarget(
  meanshape,
  PCA$shapes$shapes.comp3$max,
  method = "vector",
  mag = 2)
```

```{r}
#| label: PC3 Min vs Max Shape
plotRefToTarget(
  PCA$shapes$shapes.comp3$min,
  PCA$shapes$shapes.comp3$max,
  method = "vector",
  mag = 1)
```

# 7. PCA with *Schleizius* and *Gracilis* holotypes

```{r}
#| label: Importing the landmarks
bonus_TPS <- c("robin_conodonts.TPS", "schleiziusDzik_all.TPS", "gracilisDzik.TPS")
bonus_landmarks <- readmulti.tps(filelist = bonus_TPS,
                                 readcurves = TRUE,
                                 specID = "imageID")
```

```{r}
#| label: Procrustes Superimposition
bonus_landmarks.gpa <- gpagen(bonus_landmarks)
plot(bonus_landmarks.gpa)
```

```{r}
#| label: PCA & Selecting the holotypes for labels
bonus_PCA <- gm.prcomp(bonus_landmarks.gpa$coords) 
selected <- c(61, 62, 63, 64, 65)
```

```{r}
#| label: PC1 and PC2
plot(bonus_PCA$x[,1], bonus_PCA$x[,2],
     pch = 16,
     xlab = "PC 1",
     ylab = "PC 2",
     main = expression("PC1 and PC2 of "*italic(T.~gracilis)*" shapes"),
     xlim = c(-0.15,0.15),
     ylim = c(-0.06,0.06)
     )

text(x = bonus_PCA$x[,1][selected],
     y = bonus_PCA$x[,2][selected],
     labels = dimnames(bonus_landmarks.gpa$coords)[[3]],
     pos = 1,
     cex = 0.7
     )
```

```{r}
#| label: PC3 and PC4
plot(bonus_PCA$x[,3], bonus_PCA$x[,4],
     pch = 16,
     xlab = "PC 3",
     ylab = "PC 4",
     main = expression("PC3 and PC4 of "*italic(T.~gracilis)*" shapes"),
     xlim = c(-0.10,0.10),
     ylim = c(-0.05, 0.05)
)
text(x = bonus_PCA$x[,3][selected],
     y = bonus_PCA$x[,4][selected],
     labels = dimnames(bonus_landmarks.gpa$coords)[[3]],
     pos = 1,
     cex = 0.7
     )
```

# PCA plots with relative ages

```{r}
age.colors <- colorRampPalette(c("orange","purple"))
age.color.name <- age.colors(positions$Age)

plot(PCA$x[,1], PCA$x[,2],
     pch = 16,
     bg = age.color.name[positions$Age],
     cex = scales::rescale(positions$Age, to = c(0.6, 2)),
     col = age.color.name[positions$Age],
     xlab = "PC 1: 40.46%",
     ylab = "PC 2: 19.87%",
     main = expression("PC1 and PC2 of "*italic(T.~gracilis)*" shapes"),
     xlim = c(-0.10,0.10),
     ylim = c(-0.06,0.06)
)
```

```{r}
plot(PCA$x[,3], PCA$x[,4],
     pch = 16,
     bg = age.color.name[positions$Age],
     cex = scales::rescale(positions$Age, to = c(0.6, 2)),
     col = age.color.name[positions$Age],
     xlab = "PC 3: 14.65%",
     ylab = "PC 4: 6.55%",
     main = expression("PC3 and PC4 of "*italic(T.~gracilis)*" shapes"),
     xlim = c(-0.06,0.06),
     ylim = c(-0.04,0.04)
)
```

# Position in section

```{r}
heights <- read.csv(file = "BedHeights.csv",
                    sep = ",",
                    header = T)
```

```{r}
#| label: Extract bed name from file names 2
sample_names <- gsub("\\D*","",dimnames(landmarks.gpa$coords)[[3]])
sample_names <- as.numeric(sample_names)
```

```{r}
#| label: match sample names with heights in section
sample_names <- data.frame(sample_names)
Positions2 <- merge(x = sample_names,
      y = heights,
      by.x = "sample_names",
      by.y = "Bed",
      all.x = T)
```

```{r}
height.colors<-colorRampPalette(c("orange","purple"))
height.color.name <- height.colors(Positions2$Height)

plot(PCA$x[,1], PCA$x[,2],
     pch = 16,
     bg = height.color.name[Positions2$Height],
     cex = scales::rescale(Positions2$Height, to = c(0.6, 2)),
     col = height.color.name[Positions2$Height],
     xlab = "PC 1",
     ylab = "PC 2",
     main = "PCA of the platform outline of T. gracilis",
     ylim = c(-0.07,0.07)
)
text(x = PCA$x[,1],
     y = PCA$x[,2],
     labels = round(Positions2$Height,1),
     pos = 1,
     cex = 0.7
     )
```

There doesn't seem to be any link between PC1 or PC2 and the position in section.

```{r}
model_height_pc1 <- lm(PCA$x[,1] ~ Positions2$Height)
```

```{r}
plot(Positions2$Height, PCA$x[,1], type = "p",
       xlab = "Position in section [m]",
       ylab = "PC 1")
abline(a = model_height_pc1$coefficients[1], 
       b = model_height_pc1$coefficients[2],
       col="blue")
```

The heights might need some transformation (such as standardization).

```{r}
summary(model_height_pc1)
```

The relationship between PC1 and height in section is not significant. But, again, might need some transformation.

### Size of elements

Calculate the size of each specimen (along the X axis, i.e. length)

```{r}
size <- numeric(length = dim(landmarks.gpa$coords)[3])
for (i in 1:dim(landmarks.gpa$coords)[3]) {
  size[i] <- max(landmarks.gpa$coords[,1,i]) - min(landmarks.gpa$coords[,1,i])
}
```

```{r}
my.colors<-colorRampPalette(c("red","blue"))
color.name=my.colors(dim(landmarks.gpa$coords)[3])
size.scaled <- rescale(size, to = c(1,dim(landmarks.gpa$coords)[3]))

plot(PCA$x[,1], PCA$x[,2],
     pch = 16,
     bg = color.name[size.scaled],
     cex = rescale(size, to = c(0.6, 2)),
     col = color.name[size.scaled],
     xlab = "PC 1",
     ylab = "PC 2",
     main = "PCA of the platform outline of T. gracilis"
)
```

The size and colour of the points is proportional to the size of the element. There is clearly a correlation between size and PC1.

### Regression analysis

We start with a simple linear regression.

```{r}
model_pc1 <- lm(PCA$x[,1] ~ size)
plot(size, PCA$x[,1], type = "p",
       xlab = "Size [mm]",
       ylab = "PC 1")
abline(a = model_pc1$coefficients[1], 
       b = model_pc1$coefficients[2],
       col="blue")
```

```{r}
summary(model_pc1)
```

Even though there is a big scatter around the trend, PC1 decreases significantly with the length of the element. That suggests that specimens on the right side correspond to younger individuals.

```{r}
#| label: Leaving this here for now. It was originally in the same block as the mean PC over time plot.
for (i in length(levels(Ages_PC$Age))) {
  segments(
    x0 = as.numeric(levels(Ages_PC$Age)[i]),
    x1 = as.numeric(levels(Ages_PC$Age)[i]),
    y0 = PC[[1]][1,i] - PC[[2]][1,i],
    y1 = PC[[1]][1,i] + PC[[2]][1,i],
    col = "gray"
  )
}
```
